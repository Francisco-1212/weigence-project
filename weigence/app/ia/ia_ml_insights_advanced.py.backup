"""
Análisis ML Avanzado - Insights específicos y accionables
Genera mensajes contextuales basados en análisis profundo de datos reales
"""
from __future__ import annotations

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


# Import dinámico para evitar circular dependency
def _get_supabase():
    """Obtiene cliente Supabase de forma lazy."""
    from api.conexion_supabase import supabase
    return supabase


class AdvancedMLInsights:
    """Genera insights específicos basados en análisis ML de datos reales."""
    
    def __init__(self):
        self.supabase = _get_supabase()
    
    # ==================== DASHBOARD ====================
    
    def analyze_dashboard_rankings(self) -> Dict[str, any]:
        """Analiza top productos vendidos y menos vendidos."""
        try:
            # Top 5 más vendidos últimas 48h
            response = self.supabase.table('detalle_ventas') \
                .select('productos(nombre), cantidad') \
                .gte('fecha_detalle', (datetime.now() - timedelta(hours=48)).isoformat()) \
                .execute()
            
            if response.data:
                # Agrupar por producto
                product_sales = {}
                for item in response.data:
                    if item.get('productos'):
                        prod_name = item['productos']['nombre']
                        qty = float(item.get('cantidad', 0))
                        product_sales[prod_name] = product_sales.get(prod_name, 0) + qty
                
                # Top 5 y Bottom 5
                sorted_products = sorted(product_sales.items(), key=lambda x: x[1], reverse=True)
                
                return {
                    'top_5': sorted_products[:5] if len(sorted_products) >= 5 else sorted_products,
                    'bottom_5': sorted_products[-5:] if len(sorted_products) >= 5 else [],
                    'total_products': len(sorted_products)
                }
        except Exception as e:
            logger.error(f"Error analizando rankings: {e}")
        
        return {'top_5': [], 'bottom_5': [], 'total_products': 0}
    
    # ==================== INVENTARIO ====================
    
    def analyze_inventory_capacity(self) -> Dict[str, any]:
        """Detecta estantes con capacidad excedida o productos sin stock."""
        try:
            # Productos sin stock o cerca del mínimo
            response = self.supabase.table('productos') \
                .select('nombre, stock, id_estante') \
                .execute()
            
            if response.data:
                products_without_stock = []
                products_below_min = []
                products_above_max = []
                
                for prod in response.data:
                    stock = float(prod.get('stock_actual', 0))
                    min_stock = float(prod.get('stock_minimo', 0))
                    max_stock = float(prod.get('stock_maximo', 0))
                    
                    if stock <= 0:
                        products_without_stock.append(prod['nombre'])
                    elif stock < min_stock:
                        products_below_min.append({
                            'nombre': prod['nombre'],
                            'stock': stock,
                            'min': min_stock,
                            'ubicacion': prod.get('ubicacion', 'Sin ubicación')
                        })
                    elif max_stock > 0 and stock > max_stock:
                        products_above_max.append({
                            'nombre': prod['nombre'],
                            'stock': stock,
                            'max': max_stock,
                            'ubicacion': prod.get('ubicacion', 'Sin ubicación')
                        })
                
                return {
                    'without_stock': products_without_stock,
                    'below_min': products_below_min,
                    'above_max': products_above_max
                }
        except Exception as e:
            logger.error(f"Error analizando capacidad inventario: {e}")
        
        return {'without_stock': [], 'below_min': [], 'above_max': []}
    
    # ==================== MOVIMIENTOS ====================
    
    def analyze_unjustified_movements(self) -> Dict[str, any]:
        """Detecta retiros no justificados con ventas."""
        try:
            # Retiros últimas 24h
            withdrawals = self.supabase.table('movimientos_inventario') \
                .select('id, producto_id, cantidad, tipo_movimiento, created_at, productos(nombre)') \
                .eq('tipo_movimiento', 'retiro') \
                .gte('created_at', (datetime.now() - timedelta(hours=24)).isoformat()) \
                .execute()
            
            if not withdrawals.data:
                return {'unjustified': [], 'total_withdrawals': 0}
            
            unjustified = []
            
            for withdrawal in withdrawals.data:
                product_id = withdrawal.get('producto_id')
                qty = float(withdrawal.get('cantidad', 0))
                timestamp = withdrawal.get('created_at')
                
                # Buscar venta correspondiente en ventana de ±2 horas
                start_time = (datetime.fromisoformat(timestamp.replace('Z', '+00:00')) - timedelta(hours=2)).isoformat()
                end_time = (datetime.fromisoformat(timestamp.replace('Z', '+00:00')) + timedelta(hours=2)).isoformat()
                
                sales = self.supabase.table('detalle_ventas') \
                    .select('cantidad') \
                    .eq('producto_id', product_id) \
                    .gte('created_at', start_time) \
                    .lte('created_at', end_time) \
                    .execute()
                
                total_sold = sum(float(s.get('cantidad', 0)) for s in sales.data) if sales.data else 0
                
                # Si retiro > ventas, es sospechoso
                if qty > total_sold + 1:  # +1 margen de tolerancia
                    unjustified.append({
                        'producto': withdrawal['productos']['nombre'] if withdrawal.get('productos') else 'Desconocido',
                        'cantidad_retirada': qty,
                        'cantidad_vendida': total_sold,
                        'diferencia': qty - total_sold,
                        'timestamp': timestamp
                    })
            
            return {
                'unjustified': unjustified,
                'total_withdrawals': len(withdrawals.data)
            }
        except Exception as e:
            logger.error(f"Error analizando movimientos no justificados: {e}")
        
        return {'unjustified': [], 'total_withdrawals': 0}
    
    # ==================== VENTAS ====================
    
    def analyze_sales_comparison_48h(self) -> Dict[str, any]:
        """Compara ventas últimas 24h vs 24h anteriores."""
        try:
            now = datetime.now()
            
            # Últimas 24h
            recent_sales = self.supabase.table('ventas') \
                .select('total') \
                .gte('fecha_venta', (now - timedelta(hours=24)).isoformat()) \
                .execute()
            
            # 24h anteriores (48h - 24h atrás)
            previous_sales = self.supabase.table('ventas') \
                .select('total') \
                .gte('fecha_venta', (now - timedelta(hours=48)).isoformat()) \
                .lt('fecha_venta', (now - timedelta(hours=24)).isoformat()) \
                .execute()
            
            recent_total = sum(float(s.get('total', 0)) for s in recent_sales.data) if recent_sales.data else 0
            previous_total = sum(float(s.get('total', 0)) for s in previous_sales.data) if previous_sales.data else 0
            
            if previous_total > 0:
                change_percent = ((recent_total - previous_total) / previous_total) * 100
            else:
                change_percent = 0
            
            # Analizar por producto más vendido
            recent_details = self.supabase.table('detalle_ventas') \
                .select('productos(nombre), cantidad') \
                .gte('created_at', (now - timedelta(hours=24)).isoformat()) \
                .execute()
            
            product_sales = {}
            if recent_details.data:
                for item in recent_details.data:
                    if item.get('productos'):
                        prod = item['productos']['nombre']
                        qty = float(item.get('cantidad', 0))
                        product_sales[prod] = product_sales.get(prod, 0) + qty
            
            top_product = max(product_sales.items(), key=lambda x: x[1]) if product_sales else ('Sin datos', 0)
            
            return {
                'recent_total': recent_total,
                'previous_total': previous_total,
                'change_percent': change_percent,
                'top_product': top_product[0],
                'top_product_qty': top_product[1],
                'recent_count': len(recent_sales.data) if recent_sales.data else 0,
                'previous_count': len(previous_sales.data) if previous_sales.data else 0
            }
        except Exception as e:
            logger.error(f"Error comparando ventas 48h: {e}")
        
        return {
            'recent_total': 0,
            'previous_total': 0,
            'change_percent': 0,
            'top_product': 'Sin datos',
            'top_product_qty': 0,
            'recent_count': 0,
            'previous_count': 0
        }
    
    # ==================== ALERTAS ====================
    
    def analyze_critical_alerts_resolution(self) -> Dict[str, any]:
        """Analiza alertas críticas y sugiere resoluciones específicas."""
        try:
            # Alertas críticas activas
            critical = self.supabase.table('alertas') \
                .select('tipo, mensaje, created_at, producto_id, productos(nombre)') \
                .eq('severidad', 'critical') \
                .eq('estado', 'activa') \
                .order('created_at', desc=True) \
                .limit(10) \
                .execute()
            
            if not critical.data:
                return {'alerts': [], 'total': 0, 'oldest_hours': 0}
            
            alerts_with_resolution = []
            for alert in critical.data:
                tipo = alert.get('tipo', '')
                mensaje = alert.get('mensaje', '')
                producto = alert['productos']['nombre'] if alert.get('productos') else 'Sistema'
                created = alert.get('created_at')
                
                # Calcular antigüedad
                created_dt = datetime.fromisoformat(created.replace('Z', '+00:00'))
                hours_old = (datetime.now(created_dt.tzinfo) - created_dt).total_seconds() / 3600
                
                # Sugerir resolución según tipo
                resolution = self._get_alert_resolution(tipo, producto)
                
                alerts_with_resolution.append({
                    'tipo': tipo,
                    'mensaje': mensaje,
                    'producto': producto,
                    'hours_old': round(hours_old, 1),
                    'resolution': resolution
                })
            
            oldest = max(a['hours_old'] for a in alerts_with_resolution) if alerts_with_resolution else 0
            
            return {
                'alerts': alerts_with_resolution,
                'total': len(alerts_with_resolution),
                'oldest_hours': round(oldest, 1)
            }
        except Exception as e:
            logger.error(f"Error analizando alertas críticas: {e}")
        
        return {'alerts': [], 'total': 0, 'oldest_hours': 0}
    
    def _get_alert_resolution(self, tipo: str, producto: str) -> str:
        """Sugiere resolución específica según tipo de alerta."""
        resolutions = {
            'stock_bajo': f'Generar orden de compra para {producto}. Contactar proveedor.',
            'stock_critico': f'URGENTE: Reposición inmediata de {producto}. Verificar ventas pendientes.',
            'sensor_error': f'Revisar calibración de balanza. Validar conexión del sensor.',
            'peso_anomalo': f'Verificar producto {producto}. Posible error en registro o deterioro.',
            'sin_movimiento': f'Revisar conectividad de sistema. Validar procesos operativos.',
            'venta_sin_stock': f'Verificar registro de venta. Ajustar inventario de {producto}.',
        }
        return resolutions.get(tipo, f'Revisar alerta de {producto}. Contactar supervisor.')
    
    # ==================== AUDITORÍA ====================
    
    def analyze_audit_anomalies(self) -> Dict[str, any]:
        """Detecta patrones anómalos en auditoría."""
        try:
            # Movimientos sin justificar por usuario
            recent_events = self.supabase.table('auditoria_eventos') \
                .select('usuario_email, tipo_evento, detalles, created_at') \
                .gte('created_at', (datetime.now() - timedelta(hours=1)).isoformat()) \
                .execute()
            
            if not recent_events.data:
                return {'total_events': 0, 'suspicious_users': [], 'event_rate': 0}
            
            # Contar eventos por usuario
            user_events = {}
            for event in recent_events.data:
                user = event.get('usuario_email', 'Sistema')
                user_events[user] = user_events.get(user, 0) + 1
            
            # Usuarios con actividad sospechosa (>20 eventos en 1h)
            suspicious = [
                {'usuario': user, 'eventos': count}
                for user, count in user_events.items()
                if count > 20
            ]
            
            return {
                'total_events': len(recent_events.data),
                'suspicious_users': suspicious,
                'event_rate': round(len(recent_events.data) / 1.0, 1),  # eventos/hora
                'unique_users': len(user_events)
            }
        except Exception as e:
            logger.error(f"Error analizando anomalías de auditoría: {e}")
        
        return {'total_events': 0, 'suspicious_users': [], 'event_rate': 0, 'unique_users': 0}


# Instancia global
_advanced_insights: Optional[AdvancedMLInsights] = None


def get_advanced_insights() -> AdvancedMLInsights:
    """Retorna instancia singleton."""
    global _advanced_insights
    if _advanced_insights is None:
        _advanced_insights = AdvancedMLInsights()
    return _advanced_insights
